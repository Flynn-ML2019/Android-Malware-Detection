# -*- coding: UTF-8 -*-
import os
import sys
from androguard.core.bytecodes import apk
from androguard.core.bytecodes import dvm
from androguard.core.analysis import analysis
import datetime
from multiprocessing import Pool,Lock,Process

'''
敏感API smali形式
'''
dict_api={
'IActivityManager$Stub$Proxy;->shutdown' : '关机',
'ActivityManager;->killBackgroundProcesses' : '中断进程，可用于关闭杀软',
'ActivityManagerNative;->killBackgroundProcesses' : '中断进程，可用于关闭杀软',
'ActivityManagerNative;->restartPackage' : ' 中断进程，可用于关闭杀软',
'ActivityManager;->restartPackage' : ' 中断进程，可用于关闭杀软',
'BluetoothAdapter;->enable' : '开启蓝牙',
'BluetoothSocket;->connect' : '连接蓝牙',
'Camera;->open' : '开启相机',
'MediaRecorder;->setAudioSource' : '开启录音功能',
'MediaRecorder;->setVideoSource' : '开启视频录制',
'LocationManager;->getLastKnownLocation' : '获取地址位置',
'Downloads$ByUri;->startDownloadByUri' : '下载文件',
'Downloads$DownloadBase;->startDownloadByUri' : '下载文件',
'PowerManager;->reboot' : '重启手机',
'Settings$Bookmarks;->add' : '添加浏览器书签',
'TelephonyManager;->getDeviceId' : '搜集用户手机IMEI码、电话号码、系统版本号等信息',
'TelephonyManager;->getSimSerialNumber()' : '获取SIM序列号',
'Telephony$Mms;->query' : '读取短信',
'TelephonyManager;->getLine1Number' : '获取手机号',
'SpeechRecognizer;->startListening' : '开启麦克风',
'WifiManager;->setWifiEnabled' : '开启WIFI',
'SmsManager;->getAllMessagesFromSim' : '获取sim卡上的短信',
'SmsManager;->sendDataMessage' : '发送二进制消息',
'SmsManager;->sendMultipartTextMessage' : '发送彩信',
'SmsManager;->sendTextMessage' : '发送普通短信',
'http/multipart/FilePart;->sendData' : '发送http请求',
'http/multipart/Part;->send' : '发送http请求',
'http/multipart/Part;->sendParts' : '发送http请求',
'http/multipart/StringPart;->sendData' : '发送http请求',
'internal/telephony/ISms$Stub$Proxy;->sendData' : '发送短信',
'internal/telephony/ISms$Stub$Proxy;->sendMultipartText' : '发送短信',
'internal/telephony/ISms$Stub$Proxy;->sendText' : '发送短信',
'internal/telephony/ITelephony$Stub$Proxy;->call' : '拔打电话',
'java/lang/Runtime;->exec' : '执行字符串命令',
'java/net/HttpURLConnection;->connect' : '连接URL',
'java/net/URL;->getContent' : '获取网页内容',
'java/net/URL;->openConnection' : '连接URL',
'java/net/URLConnection;->connect' : '连接URL',
'DefaultHttpClient;->execute' : '发送HTTP请求',
'HttpClient;->execute' : '请求远程服务器',
'android/app/NotificationManager;->notify' : '信息通知栏',
'SmsReceiver;->abortBroadcast' : '拦截短信接收',
'ContentResolver;->delete' : '删除短信、联系人',
'chmod ' : '更改文件权限',
'getRuntime' : '获取命令行环境',
'content://telephony/carriers' : '获取所有的APN（网络接入点）配置信息',
'content://telephony/carriers/preferapn' : '可能用于篡改APN（网络接入点）以调用应用市场M-Market扣费接口并验证',
'content://sms' : '获取短信数据库',
'content://browser/bookmarks' : '获取浏览器书签',
'mount -o remount' : '重新挂载档案系统',
'/system/bin/sh' : '执行shell',
'/proc/mounts' : '加载文件系统',
'/system/bin/cp' : '复制文件',
'/root/su' : '切换用户',
'/system/bin/rm ' : '删除文件'
}
#权限全局变量
info=[]
'''
将权限组转化成特征向量
'''

#特征向量组一
list1=[
'android.permission.WRITE_CONTACTS'
,'android.permission.GET_ACCOUNTS' 
,'android.permission.READ_CONTACTS'
]

#特征向量组二
list2=[
'android.permission.READ_CALENDAR'
,'android.permission.WRITE_CALENDAR'
]

#特征向量组三
list3=['android.permission.READ_CALL_LOG',
'android.permission.READ_PHONE_STATE',
'android.permission.CALL_PHONE',
'android.permission.WRITE_CALL_LOG',
'android.permission.USE_SIP',
'android.permission.PROCESS_OUTGOING_CALLS',
'com.android.voicemail.permission.ADD_VOICEMAIL']

#特征向量组四
list4=[
'android.permission.ACCESS_FINE_LOCATION'
,'android.permission.ACCESS_COARSE_LOCATION'
]

#特征向量组五
list5=[
'android.permission.READ_EXTERNAL_STORAGE'
,'android.permission.WRITE_EXTERNAL_STORAGE'
]

#特征向量组六
list6=[
'android.permission.RECORD_AUDIO'
]

#特征向量组七
list7=[
'android.permission.READ_SMS'
,'android.permission.RECEIVE_WAP_PUSH'
,'android.permission.RECEIVE_MMS'
,'android.permission.RECEIVE_SMS'
,'android.permission.SEND_SMS'
,'android.permission.READ_CELL_BROADCASTS'
]

#恶意apk路径
base_address="/home/admin/good_apk_test/"

#获得list 特征向量
def get_tz(info):
 flag1=0
 count1=0
 for i in range(len(list1)):
     for j in range(len(info)):
      if list1[i]==info[j]:       
       count1=count1+1
 if count1!=0:
  flag1=1

 flag2=0
 count2=0
 for i in range(len(list2)):
     for j in range(len(info)):
      if list2[i]==info[j]:
       count2=count2+1
 if count2!=0:
  flag2=1

 flag3=0
 count3=0
 for i in range(len(list3)):
     for j in range(len(info)):
      if list3[i]==info[j]:
       count3=count3+1
 if count3!=0:
  flag3=1


 flag4=0
 count4=0
 for i in range(len(list4)):
     for j in range(len(info)):
      if list4[i]==info[j]:
       count4=count4+1
 if count4!=0:
  flag4=1


 flag5=0
 count5=0
 for i in range(len(list5)):
     for j in range(len(info)):
      if list5[i]==info[j]:
       count5=count5+1
 if count5!=0:
  flag5=1

 flag6=0
 count6=0
 for i in range(len(list6)):
     for j in range(len(info)):
      if list6[i]==info[j]:
       count6=count6+1
 if count6!=0:
  flag6=1


 flag7=0
 count7=0
 for i in range(len(list7)):
     for j in range(len(info)):
      if list7[i]==info[j]:
       count7=count7+1
 if count7!=0:
  flag7=1

   
 feature_vector=[flag1,flag2,flag3,flag4,flag5,flag6,flag7]

 return feature_vector

'''
字符串匹配kmp算法
'''
def kmp(mom_string,son_string):
    test=''
    if type(mom_string)!=type(test) or type(son_string)!=type(test):
        return -1
    if len(son_string)==0:
        return 0
    if len(mom_string)==0:
        return -1
    next=[-1]*len(son_string)
    if len(son_string)>1:
        next[1]=0
        i,j=1,0
        while i<len(son_string)-1:
            if j==-1 or son_string[i]==son_string[j]:
                i+=1
                j+=1
                next[i]=j
            else:
                j=next[j]
    m=s=0
    while(s<len(son_string) and m<len(mom_string)):
        if s==-1 or mom_string[m]==son_string[s]:
            m+=1
            s+=1
        else:
            s=next[s]
    if s==len(son_string):
        return m-s
    return -1

'''
根据路径获取所有文件
'''
def all_path(dirname):
    result = []
    for maindir, subdir, file_name_list in os.walk(dirname):
        #print("1:",maindir)
        #print("2:",subdir)
        #print("3:",file_name_list)
        for filename in file_name_list:
            apath = os.path.join(maindir, filename)
            result.append(apath)
    return result

'''
提取文件的敏感api特征形成特征向量
'''
def get_smali(i):
  result=[]
  list_tz=list(dict_api.keys())
    #某apk的全部smali信息
  f2=open("".join(i).strip(".apk")+".txt",'r')   
  size = os.path.getsize("".join(i).strip(".apk")+".txt")
  line2=f2.readline()            
  list_smali=[]  
  while line2:
    list_smali.append(line2) 
    line2=f2.readline()
  for text in list_tz:
    if kmp("".join(list_smali),str(text))!=-1:
      result.append(1)
    else:
      result.append(0)
  f2.close()
  os.system("sudo rm -rf"+"  /home/ch907722751/"+"".join(i).strip(".apk")+".txt")
  os.system("sudo rm -rf"+"  /home/ch907722751/"+"".join(i).strip(".apk"))
  return result


'''
读每个apk形成其smail文件
'''
def workOne(i):
  os.system("apktool d -f "+base_address+i+"  -o  "+"".join(i).strip(".apk"))
  if not os.listdir("/home/ch907722751/"+"".join(i).strip(".apk")):
  	print('file empty.........')
  	os.system("sudo rm -rf"+"  /home/ch907722751/"+"".join(i).strip(".apk"))
  	exit()  
  f1 = open("".join(i).strip(".apk")+".txt",'w')                     
        
  for Text in all_path("/home/ch907722751/"+"".join(i).strip(".apk")+"/smali"):
      f2 = open(Text,'r')   
      line = f2.readline()       
      while line:  
          f1.write(line.strip('\n')) 
          f1.flush()   
          line = f2.readline()
  #提取权限信息     
  try:
    apk_info = apk.APK(base_address+"".join(i))   
    info=apk_info.get_permissions() 
    f3=open("result.txt",'a')
    f1.close() 
    f2.close()   
    list_last=get_tz(info)+get_smali(i)
    f3.write(str(list_last).replace(",","").replace("[","").replace("]","").replace(" ","")+"\n")
    f3.flush()
    f3.close()
    #os.system("sudo rm -r"+"  /home/ch907722751/"+"".join(i).strip(".apk"))
  except Exception as e:
  	  print("Exception find...")
  	  exit()
      #os.system("sudo rm -r"+"  /home/ch907722751/"+"".join(i).strip(".apk"))
starttime = datetime.datetime.now()
pool = Pool(processes=15)      #定义最大的进程数

for i in os.listdir(base_address):  
  pool.apply_async(workOne, args=(i,))

print("for overs...............")
pool.close()
pool.join()
print("join overs...............")          
endtime = datetime.datetime.now()
print(endtime - starttime).seconds
os.system("ps -ef | grep python | cut -c 9-15| xargs kill -s 9")
exit()